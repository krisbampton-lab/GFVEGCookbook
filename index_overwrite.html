<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GF Veg Cookbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f7faf7;--card:#ffffff;--border:#d1e2d1;--accent:#2f7c4f;--muted:#5f6f5f;
      --soft:#e5f5eb;--soft2:#edf7ef;--warn:#b03030;--amber:#a86800;
      --shadow:0 2px 8px rgba(0,0,0,.06);--r:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:var(--bg);color:#1f2a1f}
    header{position:sticky;top:0;z-index:50;background:var(--card);border-bottom:1px solid var(--border)}
    .wrap{max-width:1200px;margin:0 auto;padding:1rem 1.25rem}
    .top{display:flex;gap:.75rem 1rem;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .brand{display:flex;flex-direction:column;gap:.15rem}
    .brand .t{font-weight:800;letter-spacing:.06em;text-transform:uppercase;color:var(--accent)}
    .brand .s{font-size:.85rem;color:var(--muted)}
    .controls{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap}
    .search{display:flex;gap:.4rem;align-items:center;padding:.45rem .7rem;border:1px solid var(--border);border-radius:999px;background:var(--bg);min-width:240px}
    .search input{border:none;outline:none;background:transparent;width:100%;font-size:.95rem}
    select{border:1px solid var(--border);border-radius:999px;padding:.4rem .75rem;background:var(--card)}
    main .grid{max-width:1200px;margin:0 auto;padding:1rem 1.25rem 1.25rem;display:grid;grid-template-columns:minmax(0,1.05fr) minmax(0,1.55fr);gap:1rem;align-items:start}
    @media(max-width:900px){main .grid{grid-template-columns:1fr}}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:var(--r);box-shadow:var(--shadow);padding:.85rem}
    .ph{display:flex;align-items:center;justify-content:space-between;gap:.75rem;margin-bottom:.5rem}
    .pt{font-size:.85rem;letter-spacing:.14em;text-transform:uppercase;color:var(--muted);font-weight:700}
    .count{font-size:.8rem;color:var(--muted)}
    .list{max-height:calc(100vh - 220px);overflow:auto;padding-right:.25rem}
    @media(max-width:900px){.list{max-height:none}}
    .sec{margin-top:.85rem;font-size:.75rem;letter-spacing:.12em;text-transform:uppercase;color:var(--accent);opacity:.85;font-weight:700}
    .card{border:1px solid #e1efe4;background:#f9fcf9;border-radius:12px;padding:.45rem .6rem;cursor:pointer;display:flex;flex-direction:column;gap:.15rem;transition:transform .05s ease, background .15s ease, border-color .15s ease}
    .card:hover{background:#f2f8f3;border-color:#cfe8d7;transform:translateY(-1px)}
    .card.sel{border-color:var(--accent);background:var(--soft2)}
    .rt{font-weight:700;font-size:.95rem;color:#2f422f}
    .rm{font-size:.75rem;color:var(--muted)}
    .empty{color:var(--muted);font-size:.9rem;padding:.75rem .25rem}
    .err{color:var(--warn);font-size:.9rem;padding:.75rem .25rem}
    .detail{max-height:calc(100vh - 220px);overflow:auto;padding-right:.25rem}
    @media(max-width:900px){.detail{max-height:none}}
    .dh{border-bottom:1px solid var(--border);padding-bottom:.5rem;margin-bottom:.6rem}
    .dh .title{font-size:1.15rem;font-weight:800;margin:.1rem 0}
    .dh .meta{color:var(--muted);font-size:.85rem;margin:.15rem 0}
    .badges{display:flex;gap:.35rem;flex-wrap:wrap;margin-top:.35rem}
    .badge{border:1px solid var(--border);background:#f5faf6;border-radius:999px;padding:.12rem .5rem;font-size:.72rem;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);font-weight:700}
    .badge.a{border-color:var(--accent);color:var(--accent);background:var(--soft)}
    .badge.w{border-color:#f0a000;color:var(--amber);background:#fff6e8}
    .badge.e{border-color:#b03030;color:#b03030;background:#ffecec}
    .cols{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:.75rem}
    @media(max-width:900px){.cols{grid-template-columns:1fr}}
    .block{border:1px solid #e0eee2;background:#f9fcf9;border-radius:12px;padding:.6rem .7rem;font-size:.92rem}
    .block h4{margin:0 0 .35rem;font-size:.8rem;letter-spacing:.14em;text-transform:uppercase;color:var(--muted)}
    .block ul, .block ol{margin:.25rem 0 .1rem 1.15rem;padding:0}
    .block li{margin:.12rem 0}
    .note{margin-top:.4rem;color:var(--muted);font-size:.8rem}
    .mono{font-family:var(--mono)}
    details{border-top:1px solid var(--border);background:#f5f8f6}
    details .wrap{padding-top:.75rem;padding-bottom:1rem}
    summary{cursor:pointer;font-weight:800;color:var(--accent);list-style:none}
    summary::-webkit-details-marker{display:none}
    .tools{display:grid;grid-template-columns:minmax(0,1.2fr) minmax(0,1fr);gap:.75rem;margin-top:.75rem}
    @media(max-width:900px){.tools{grid-template-columns:1fr}}
    textarea.small{min-height:140px}
    button{border:1px solid var(--accent);background:var(--soft);color:var(--accent);border-radius:999px;padding:.35rem .8rem;font-weight:700;cursor:pointer}
    button.secondary{border-color:#cfe8d7;background:#edf7ef;color:#2f7c4f}
    pre{white-space:pre-wrap;background:#fff;border:1px solid #cfd8cf;border-radius:10px;padding:.6rem;max-height:240px;overflow:auto;font-size:.8rem}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <div class="t">GF Veg Cookbook</div>
        <div class="s">Auto macros from ingredient lines (heuristics + ingredient DB). No ingredients_meta required.</div>
      </div>
      <div class="controls">
        <div class="search"><span>üîç</span><input id="q" type="search" placeholder="Search title, section, ingredients‚Ä¶" /></div>
        <select id="sec"><option value="">All sections</option></select>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="panel">
      <div class="ph">
        <div class="pt">Recipes</div>
        <div class="count" id="count"></div>
      </div>
      <div class="list" id="list"></div>
      <div class="empty" id="listMsg" style="display:none;"></div>
    </section>

    <section class="panel">
      <div class="ph">
        <div class="pt">Details</div>
        <div class="count" id="macroConfidence"></div>
      </div>
      <div class="detail" id="detail">
        <div class="empty">Select a recipe.</div>
      </div>
    </section>
  </div>
</main>

<details>
  <div class="wrap">
    <summary>Tools</summary>

    <div class="tools">
      <div class="panel" style="box-shadow:none;">
        <div class="pt" style="margin-bottom:.5rem;">Coverage checker</div>
        <div class="note">Scans all recipes and lists inferred ingredient IDs missing from the DB (so you can fill them).</div>
        <button class="secondary" onclick="scanCoverage()">Scan coverage</button>
        <pre id="covOut"></pre>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="pt" style="margin-bottom:.5rem;">Export</div>
        <div class="note">Downloads the currently loaded recipes.json.</div>
        <button onclick="downloadRecipes()">Download recipes.json</button>
        <div class="note" style="margin-top:.75rem;">If your site can‚Äôt load recipes.json, ensure it exists beside index.html and is a valid JSON array.</div>
      </div>
    </div>
  </div>
</details>

<script>
const RECIPES_URL = "recipes.json";

/** Ingredient DB (per 10 g). Expand this list over time. */
const NUTRITION_PER_10G = {
  "black-beans":   { kcal: 12, protein: 0.9, carbs: 2.0, fat: 0.1, fiber: 0.8 },
  "kidney-beans":  { kcal: 12, protein: 0.9, carbs: 2.1, fat: 0.1, fiber: 0.8 },
  "white-beans":   { kcal: 11, protein: 0.8, carbs: 2.0, fat: 0.1, fiber: 0.7 },
  "chickpeas":     { kcal: 12, protein: 0.6, carbs: 2.0, fat: 0.2, fiber: 0.6 },
  "lentils":       { kcal: 11, protein: 0.9, carbs: 2.0, fat: 0.1, fiber: 0.8 },

  "tomato-canned": { kcal: 2, protein: 0.1, carbs: 0.4, fat: 0.0, fiber: 0.1 },

  "olive-oil":     { kcal: 88, protein: 0.0, carbs: 0.0, fat: 10.0, fiber: 0.0 },
  "canola-oil":    { kcal: 88, protein: 0.0, carbs: 0.0, fat: 10.0, fiber: 0.0 },

  "rice-cooked":   { kcal: 13, protein: 0.3, carbs: 2.9, fat: 0.0, fiber: 0.1 },
  "quinoa-cooked": { kcal: 12, protein: 0.4, carbs: 2.1, fat: 0.2, fiber: 0.2 },
  "pasta-gf":      { kcal: 14, protein: 0.5, carbs: 2.9, fat: 0.1, fiber: 0.2 },

  "maple-syrup":   { kcal: 26, protein: 0.0, carbs: 6.8, fat: 0.0, fiber: 0.0 },
  "honey":         { kcal: 30, protein: 0.0, carbs: 8.1, fat: 0.0, fiber: 0.0 },

  "flour-wheat":   { kcal: 36, protein: 1.1, carbs: 7.4, fat: 0.1, fiber: 0.3 },
  "flour-gf-mix":  { kcal: 36, protein: 0.7, carbs: 7.8, fat: 0.2, fiber: 0.5 },

  "veg-stock-paste": { kcal: 9, protein: 0.4, carbs: 1.2, fat: 0.3, fiber: 0.1 }
};

/** Heuristic assumptions (your rules) */
const RULES = {
  CAN_BEANS_G: 540,
  CAN_TOMATO_G: 400,
  TBSP_OIL_G: 15,
  TBSP_GENERIC_G: 12,
  TSP_GENERIC_G: 4,
  CUP_COOKED_BEANS_G: 170,
  CUP_COOKED_RICE_G: 180,
  SPRINKLE_FLOUR_G: 5,
  DRIZZLE_TBSP: 1
};

function round1(x){ return Math.round(x*10)/10; }
function normalizeFractions(s){
  return (s||"").replace(/¬Ω/g,"0.5").replace(/¬º/g,"0.25").replace(/¬æ/g,"0.75").replace(/‚Öì/g,"0.33").replace(/‚Öî/g,"0.67");
}

/** Map messy ingredient text to canonical IDs */
function mapTextToId(line){
  const t = (line||"").toLowerCase();

  if (t.includes("black bean")) return "black-beans";
  if (t.includes("kidney bean")) return "kidney-beans";
  if (t.includes("chickpea") || t.includes("garbanzo")) return "chickpeas";
  if (t.includes("lentil")) return "lentils";
  if (t.includes("navy bean") || t.includes("pinto bean") || t.includes("white bean")) return "white-beans";
  if (t.includes(" beans")) return "black-beans"; // generic fallback

  if (t.includes("tomato") && (t.includes("can") || t.includes("cans") || t.includes("crushed") || t.includes("diced"))) return "tomato-canned";

  if (t.includes("olive oil")) return "olive-oil";
  if (t.includes("canola oil")) return "canola-oil";
  if (t.includes("neutral oil") || t.includes("vegetable oil") || t.includes("oil")) return "olive-oil";

  if (t.includes("cooked rice") || (t.includes("rice") && t.includes("cup"))) return "rice-cooked";
  if (t.includes("quinoa") && (t.includes("cooked") || t.includes("cup"))) return "quinoa-cooked";
  if (t.includes("pasta")) return "pasta-gf";

  if (t.includes("maple syrup")) return "maple-syrup";
  if (t.includes("honey")) return "honey";

  if (t.includes("gluten-free flour") || t.includes("gf flour")) return "flour-gf-mix";
  if (t.includes("flour")) return "flour-wheat";

  if (t.includes("stock paste") || t.includes("bouillon paste") || t.includes("veg stock paste")) return "veg-stock-paste";

  return null;
}

/** Parse quantity + unit from a line */
function parseQtyUnit(raw){
  const t = normalizeFractions((raw||"").toLowerCase());

  const g = t.match(/(\d+(\.\d+)?)\s*g\b/);
  if (g) return { qty: parseFloat(g[1]), unit: "g", conf: "exact" };

  const ml = t.match(/(\d+(\.\d+)?)\s*ml\b/);
  if (ml) return { qty: parseFloat(ml[1]), unit: "ml", conf: "exact" };

  const range = t.match(/(\d+(\.\d+)?)\s*[-‚Äì]\s*(\d+(\.\d+)?)/);
  let qty = null;
  if (range) qty = parseFloat(range[1]);
  else {
    const n = t.match(/(\d+(\.\d+)?)/);
    if (n) qty = parseFloat(n[1]);
  }

  let unit = null;
  if (t.includes("cans") || t.includes("can ")) unit = "can";
  else if (t.includes("cups") || t.includes("cup ")) unit = "cup";
  else if (t.includes("tbsp") || t.includes("tablespoon")) unit = "tbsp";
  else if (t.includes("tsp") || t.includes("teaspoon")) unit = "tsp";
  else if (t.includes("drizzle")) unit = "drizzle";
  else if (t.includes("sprinkle")) unit = "sprinkle";
  else if (t.includes("pinch")) unit = "pinch";

  if (!qty && (unit === "can" || unit === "drizzle" || unit === "sprinkle" || unit === "pinch")) qty = 1;

  return { qty, unit, conf: unit ? "unit" : "guess" };
}

/** Convert quantity+unit to grams using rules */
function toGrams(id, qty, unit, raw){
  const t = (raw||"").toLowerCase();
  if (!id || !qty) return { grams: null, src: "guess" };

  if (unit === "g") return { grams: qty, src: "exact" };
  if (unit === "ml") return { grams: qty, src: "exact" }; // approximate 1 ml ~ 1 g

  if (unit === "can") {
    if (id === "tomato-canned") return { grams: qty * RULES.CAN_TOMATO_G, src: "unit" };
    if (id.endsWith("beans") || id === "chickpeas" || id === "lentils" || id === "white-beans") return { grams: qty * RULES.CAN_BEANS_G, src: "unit" };
    return { grams: qty * 400, src: "guess" };
  }

  if (unit === "cup") {
    if (id === "rice-cooked") return { grams: qty * RULES.CUP_COOKED_RICE_G, src: "unit" };
    if (id.endsWith("beans") || id === "chickpeas" || id === "lentils") return { grams: qty * RULES.CUP_COOKED_BEANS_G, src: "unit" };
    return { grams: qty * 150, src: "guess" };
  }

  if (unit === "drizzle") {
    if (id.includes("oil")) return { grams: RULES.DRIZZLE_TBSP * RULES.TBSP_OIL_G, src: "guess" };
    return { grams: RULES.DRIZZLE_TBSP * RULES.TBSP_GENERIC_G, src: "guess" };
  }

  if (unit === "tbsp") {
    if (id.includes("oil")) return { grams: qty * RULES.TBSP_OIL_G, src: "unit" };
    return { grams: qty * RULES.TBSP_GENERIC_G, src: "unit" };
  }

  if (unit === "tsp") {
    if (id.includes("oil")) return { grams: qty * (RULES.TBSP_OIL_G/3), src: "unit" };
    return { grams: qty * RULES.TSP_GENERIC_G, src: "unit" };
  }

  if (unit === "sprinkle") {
    if (id.startsWith("flour")) return { grams: RULES.SPRINKLE_FLOUR_G, src: "guess" };
    return { grams: 2, src: "guess" };
  }

  if (unit === "pinch") return { grams: 1, src: "guess" };
  if (t.includes("to taste")) return { grams: null, src: "guess" };

  return { grams: qty * 50, src: "guess" };
}

/** Extract ingredient lines from ingredients_html */
function extractLinesFromIngredientsHTML(html){
  const tmp = document.createElement("div");
  tmp.innerHTML = html || "";
  const lis = Array.from(tmp.querySelectorAll("li"))
    .map(li => (li.textContent || "").trim())
    .filter(Boolean);
  if (lis.length) return lis;

  const text = (html || "").replace(/<[^>]*>/g, "\n");
  return text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
}

function parseIngredients(recipe){
  const lines = extractLinesFromIngredientsHTML(recipe.ingredients_html || "");
  const out = [];
  for (const raw of lines){
    const id = mapTextToId(raw);
    if (!id) continue;
    const { qty, unit, conf } = parseQtyUnit(raw);
    if (!qty) continue;
    const { grams, src } = toGrams(id, qty, unit, raw);
    if (!grams || grams <= 0) continue;
    out.push({ id, grams, src, raw });
  }
  return out;
}

function computeMacros(parsed){
  const totals = { kcal:0, protein:0, carbs:0, fat:0, fiber:0 };
  let counted = 0;
  for (const p of parsed){
    const db = NUTRITION_PER_10G[p.id];
    if (!db) continue;
    const f = p.grams / 10;
    totals.kcal += (db.kcal||0) * f;
    totals.protein += (db.protein||0) * f;
    totals.carbs += (db.carbs||0) * f;
    totals.fat += (db.fat||0) * f;
    totals.fiber += (db.fiber||0) * f;
    counted++;
  }
  return { totals: {
      kcal: round1(totals.kcal),
      protein: round1(totals.protein),
      carbs: round1(totals.carbs),
      fat: round1(totals.fat),
      fiber: round1(totals.fiber)
    }, counted };
}

function inferServings(meta){
  if (!meta) return 4;
  const m = /Serves\s+(\d+)/i.exec(meta);
  if (!m) return 4;
  const n = parseInt(m[1],10);
  return Number.isFinite(n) && n>0 ? n : 4;
}

function iconFor(recipe){
  const t = (recipe.title||"").toLowerCase();
  const s = (recipe.section||"").toLowerCase();
  if (s.includes("soup") || t.includes("soup") || t.includes("stew")) return "ü•£";
  if (t.includes("bowl")) return "üç≤";
  if (t.includes("skillet")) return "üç≥";
  if (s.includes("dessert") || t.includes("cookie") || t.includes("cake")) return "üç∞";
  return "üçΩÔ∏è";
}

function confidenceBadge(parsed){
  if (!parsed.length) return { label:"No parse", cls:"e" };
  const exact = parsed.filter(p=>p.src==="exact").length;
  const unit  = parsed.filter(p=>p.src==="unit").length;
  const guess = parsed.filter(p=>p.src==="guess").length;
  const total = parsed.length;
  if (guess/total > 0.5) return { label:`Heuristic heavy (${guess}/${total} guessed)`, cls:"w" };
  if ((exact+unit)/total > 0.8) return { label:`Good (${exact+unit}/${total} solid)`, cls:"a" };
  return { label:`Mixed (${exact+unit}/${total} solid)`, cls:"w" };
}

/** App state */
let allRecipes = [];
let filtered = [];
let selectedId = null;

const elQ = document.getElementById("q");
const elSec = document.getElementById("sec");
const elList = document.getElementById("list");
const elListMsg = document.getElementById("listMsg");
const elCount = document.getElementById("count");
const elDetail = document.getElementById("detail");
const elConf = document.getElementById("macroConfidence");

function setCount(){
  elCount.textContent = allRecipes.length ? `${filtered.length} of ${allRecipes.length}` : "";
}

function buildSectionFilter(){
  const secs = Array.from(new Set(allRecipes.map(r=>r.section).filter(Boolean)))
    .sort((a,b)=>a.localeCompare(b,undefined,{sensitivity:"base"}));
  elSec.innerHTML = '<option value="">All sections</option>';
  for (const s of secs){
    const o = document.createElement("option");
    o.value = s; o.textContent = s;
    elSec.appendChild(o);
  }
}

function applyFilters(){
  const term = elQ.value.trim().toLowerCase();
  const sec = elSec.value;
  filtered = allRecipes.filter(r=>{
    if (sec && r.section !== sec) return false;
    if (!term) return true;
    const hay = `${r.title||""} ${r.section||""} ${r.meta||""} ${r.ingredients_html||""}`.toLowerCase();
    return hay.includes(term);
  });
  if (selectedId && !filtered.some(r=>r.id===selectedId)){
    selectedId = null;
    renderDetail(null);
  }
  renderList();
  setCount();
}

function renderList(){
  elList.innerHTML = "";
  elListMsg.style.display = "none";
  if (!filtered.length){
    elListMsg.style.display = "block";
    elListMsg.textContent = "No recipes match your search.";
    return;
  }
  const by = {};
  for (const r of filtered){
    const s = r.section || "Uncategorized";
    (by[s] ||= []).push(r);
  }
  const secs = Object.keys(by).sort((a,b)=>a.localeCompare(b,undefined,{sensitivity:"base"}));
  for (const s of secs){
    const h = document.createElement("div");
    h.className = "sec";
    h.textContent = s;
    elList.appendChild(h);
    for (const r of by[s]){
      const c = document.createElement("div");
      c.className = "card" + (r.id===selectedId ? " sel" : "");
      const title = document.createElement("div");
      title.className = "rt";
      title.textContent = `${iconFor(r)} ${r.title || "Untitled"}`;
      const meta = document.createElement("div");
      meta.className = "rm";
      meta.textContent = r.meta || "";
      c.appendChild(title); c.appendChild(meta);
      c.onclick = ()=>{ selectedId = r.id; renderList(); renderDetail(r); };
      elList.appendChild(c);
    }
  }
}

function renderDetail(recipe){
  if (!recipe){
    elDetail.innerHTML = '<div class="empty">Select a recipe.</div>';
    elConf.textContent = "";
    return;
  }
  const parsed = parseIngredients(recipe);
  const conf = confidenceBadge(parsed);
  elConf.innerHTML = `<span class="badge ${conf.cls}">${conf.label}</span>`;

  const { totals } = computeMacros(parsed);
  const servings = inferServings(recipe.meta);
  const per = {
    kcal: round1(totals.kcal/servings),
    protein: round1(totals.protein/servings),
    carbs: round1(totals.carbs/servings),
    fat: round1(totals.fat/servings),
    fiber: round1(totals.fiber/servings)
  };

  const header = `
    <div class="dh">
      <div class="title">${recipe.title || "Untitled"}</div>
      <div class="meta">${(recipe.section? recipe.section+" ¬∑ ":"")}${recipe.meta||""}</div>
      <div class="badges">
        <span class="badge a">Gluten-Free</span>
        <span class="badge a">Vegetarian</span>
        <span class="badge ${conf.cls}">${conf.label}</span>
      </div>
    </div>
  `;

  const ing = `<div class="block"><h4>Ingredients</h4>${recipe.ingredients_html || "<p>No ingredients.</p>"}</div>`;
  const method = `<div class="block"><h4>Method</h4>${recipe.method_html || "<p>No method.</p>"}</div>`;
  const usage = `<div class="block"><h4>How to use & storage</h4>${recipe.usage_html || "<p>No notes.</p>"}</div>`;

  const parsedRows = parsed.slice(0, 14).map(p =>
    `<li><span class="mono">${p.id}</span> ‚Äî ${round1(p.grams)} g <span class="badge ${p.src==="exact"?"a":(p.src==="unit"?"w":"e")}">${p.src}</span></li>`
  ).join("");
  const parsedHtml = parsed.length ? `<ul>${parsedRows}</ul>${parsed.length>14?`<div class="note">Showing 14 of ${parsed.length} parsed lines.</div>`:""}` : `<p class="note">No macro-relevant ingredients detected from text (or no mapping rules yet).</p>`;

  const nut = `
    <div class="block">
      <h4>Macros</h4>
      <ul>
        <li><b>Per serving</b> (Serves ${servings}): ${per.kcal} kcal ¬∑ P ${per.protein} g ¬∑ C ${per.carbs} g ¬∑ F ${per.fat} g ¬∑ Fiber ${per.fiber} g</li>
        <li><b>Total recipe</b>: ${totals.kcal} kcal ¬∑ P ${totals.protein} g ¬∑ C ${totals.carbs} g ¬∑ F ${totals.fat} g ¬∑ Fiber ${totals.fiber} g</li>
      </ul>
      <div class="note">Heuristic engine based on ingredient lines. Your rules: 1 can beans = ${RULES.CAN_BEANS_G} g, 1 can tomatoes = ${RULES.CAN_TOMATO_G} g, drizzle = 1 tbsp.</div>
      <h4 style="margin-top:.7rem;">What the engine counted</h4>
      ${parsedHtml}
    </div>
  `;

  elDetail.innerHTML = header + `<div class="cols"><div>${ing}${usage}</div><div>${method}${nut}</div></div>`;
}

/** Tools */
function scanCoverage(){
  const out = document.getElementById("covOut");
  if (!allRecipes.length){ out.textContent = "No recipes loaded."; return; }
  const used = new Map(); // id -> {count, ex[]}
  let parsedItems = 0;

  for (const r of allRecipes){
    const parsed = parseIngredients(r);
    parsedItems += parsed.length;
    for (const p of parsed){
      if (!used.has(p.id)) used.set(p.id, { count:0, ex:[] });
      const o = used.get(p.id);
      o.count++;
      if (o.ex.length < 3) o.ex.push(r.title || r.id || "Untitled");
    }
  }

  const ids = Array.from(used.keys()).sort();
  const missing = ids.filter(id => !NUTRITION_PER_10G[id]);

  const lines = [];
  lines.push(`Recipes: ${allRecipes.length}`);
  lines.push(`Parsed macro-relevant items: ${parsedItems}`);
  lines.push(`Unique inferred IDs: ${ids.length}`);
  lines.push(`Missing from DB: ${missing.length}`);
  lines.push("");

  if (missing.length){
    lines.push("Missing IDs:");
    for (const id of missing){
      const ex = used.get(id)?.ex?.join(" | ") || "";
      lines.push(`- ${id} (e.g. ${ex})`);
    }
    lines.push("");
    lines.push("Skeleton DB entries:");
    for (const id of missing){
      lines.push(`"${id}": { kcal: 0, protein: 0, carbs: 0, fat: 0, fiber: 0 },`);
    }
  } else {
    lines.push("All inferred IDs are covered in the DB.");
  }
  out.textContent = lines.join("\n");
}

function downloadRecipes(){
  const blob = new Blob([JSON.stringify(allRecipes, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "recipes.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

window.scanCoverage = scanCoverage;
window.downloadRecipes = downloadRecipes;

/** Load */
async function load(){
  try{
    const res = await fetch(RECIPES_URL, { cache:"no-store" });
    if (!res.ok) throw new Error("Could not load recipes.json");
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("recipes.json must be an array");
    allRecipes = data;
    filtered = [...allRecipes];
    buildSectionFilter();
    renderList();
    setCount();
  }catch(e){
    console.error(e);
    elList.innerHTML = "";
    elListMsg.style.display = "block";
    elListMsg.className = "err";
    elListMsg.textContent = "Error loading recipes.json. Ensure it exists beside index.html and is valid JSON array.";
  }
}

elQ.addEventListener("input", applyFilters);
elSec.addEventListener("change", applyFilters);

load();
</script>
</body>
</html>
