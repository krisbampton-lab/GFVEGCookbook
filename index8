<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GF Veg Cookbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f7faf7; --card:#fff; --border:#d1e2d1; --muted:#5f6f5f;
      --accent:#2f7c4f; --accentSoft:#cfe8d7; --shadow:0 2px 8px rgba(0,0,0,.06);
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:var(--bg);color:#1f2a1f}
    header{position:sticky;top:0;z-index:50;background:var(--card);border-bottom:1px solid var(--border)}
    .wrap{max-width:1200px;margin:0 auto;padding:1rem 1.25rem}
    .head{display:flex;gap:1rem;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .brand{display:flex;flex-direction:column;gap:.1rem}
    .brand h1{margin:0;font-size:1.2rem;letter-spacing:.06em;text-transform:uppercase;color:var(--accent)}
    .brand .sub{font-size:.85rem;color:var(--muted)}
    .controls{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center}
    .pill{display:flex;gap:.45rem;align-items:center;background:var(--bg);border:1px solid var(--border);border-radius:999px;padding:.45rem .7rem}
    .pill input{border:none;outline:none;background:transparent;font-size:.9rem;min-width:220px}
    select{border:1px solid var(--border);border-radius:999px;padding:.42rem .8rem;background:var(--card);font-size:.9rem;color:#1f2a1f}
    main{padding:1rem 1.25rem 0}
    .grid{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:minmax(0,1.05fr) minmax(0,1.45fr);gap:1rem;align-items:start}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:.85rem}
    .panelHead{display:flex;align-items:center;justify-content:space-between;gap:.75rem;margin-bottom:.5rem}
    .panelTitle{font-size:.78rem;letter-spacing:.14em;text-transform:uppercase;color:var(--muted);font-weight:700}
    .panelBody{max-height:calc(100vh - 210px);overflow:auto;padding-right:.2rem}
    @media (max-width:900px){.panelBody{max-height:none}}
    .sectionLabel{margin:.9rem 0 .35rem;font-size:.72rem;letter-spacing:.14em;text-transform:uppercase;color:var(--accent);opacity:.85;font-weight:700}
    .cardItem{border:1px solid #e1efe4;background:#f9fcf9;border-radius:12px;padding:.5rem .6rem;cursor:pointer;transition:.12s ease}
    .cardItem:hover{transform:translateY(-1px);background:#f2f8f3;border-color:var(--accentSoft)}
    .cardItem.selected{border-color:var(--accent);background:#edf7ef}
    .cardTitle{font-weight:700;font-size:.92rem;margin:0 0 .1rem;color:#2f422f}
    .cardMeta{font-size:.75rem;color:var(--muted)}
    .detailHeader{border-bottom:1px solid var(--border);padding-bottom:.45rem;margin-bottom:.65rem}
    .detailHeader h2{margin:0 0 .15rem;font-size:1.05rem}
    .detailMeta{font-size:.82rem;color:var(--muted)}
    .badgeRow{display:flex;flex-wrap:wrap;gap:.35rem;margin-top:.4rem}
    .badge{border:1px solid var(--accentSoft);background:#f3fbf5;color:var(--accent);border-radius:999px;padding:.12rem .5rem;font-size:.7rem;font-weight:700;letter-spacing:.1em;text-transform:uppercase}
    .cols{display:grid;grid-template-columns:minmax(0,.95fr) minmax(0,1.05fr);gap:.75rem}
    @media (max-width:900px){.cols{grid-template-columns:1fr}}
    .block{border:1px solid #e0eee2;background:#f9fcf9;border-radius:12px;padding:.65rem .75rem;font-size:.9rem}
    .block h3{margin:0 0 .4rem;font-size:.78rem;letter-spacing:.14em;text-transform:uppercase;color:var(--muted)}
    .block ul,.block ol{margin:.25rem 0 .25rem 1.1rem;padding:0}
    .note{font-size:.78rem;color:var(--muted);margin-top:.45rem}
    .btn{border:1px solid var(--accent);background:#e5f5eb;color:var(--accent);border-radius:999px;padding:.32rem .72rem;font-size:.78rem;font-weight:700;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    details{border:1px dashed var(--border);border-radius:12px;background:#f8fbf8;padding:.55rem .7rem}
    details summary{cursor:pointer;font-weight:700;color:var(--accent);list-style:none}
    details summary::-webkit-details-marker{display:none}
    .toolGrid{display:grid;grid-template-columns:minmax(0,1.3fr) minmax(0,1fr);gap:.75rem;margin-top:.65rem}
    @media (max-width:900px){.toolGrid{grid-template-columns:1fr}}
    pre{white-space:pre;background:#fff;border:1px solid #cfd8cf;border-radius:10px;padding:.65rem;overflow:auto;max-height:260px;font-size:.78rem}
    .status{font-size:.78rem;color:var(--muted)}
    .status.ok{color:var(--accent)}
    .status.bad{color:#b03030}
  </style>
</head>
<body>
<header>
  <div class="wrap head">
    <div class="brand">
      <h1>GF Veg Cookbook</h1>
      <div class="sub">Fast recipes + macro engine with sensible defaults.</div>
    </div>
    <div class="controls">
      <div class="pill"><span>üîç</span><input id="searchInput" type="search" placeholder="Search title, notes, ingredients‚Ä¶" /></div>
      <select id="sectionFilter"><option value="">All sections</option></select>
      <button class="btn" id="downloadBtn" type="button">‚¨á Download recipes.json</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="panel">
      <div class="panelHead">
        <div class="panelTitle">Recipes</div>
        <div class="panelTitle" id="countEl" style="opacity:.75"></div>
      </div>
      <div class="panelBody">
        <div id="listEl"></div>
        <div id="listMsg" class="status" style="display:none;padding:.6rem .15rem"></div>
      </div>
    </section>

    <section class="panel">
      <div class="panelHead">
        <div class="panelTitle">Details</div>
        <button class="btn" type="button" id="scanBtn">Scan missing ingredients</button>
      </div>
      <div class="panelBody" id="detailEl">
        <div class="status">Select a recipe to view ingredients, method, and auto macros.</div>
      </div>
    </section>
  </div>
</main>

<div class="wrap" style="padding:1rem 1.25rem 1.25rem">
  <details>
    <summary>Tools (merge JSON + ingredient meta helper + scan output)</summary>

    <div class="toolGrid">
      <div>
        <div class="status" style="margin:.1rem 0 .35rem">Merge two JSON files (by <span style="font-family:ui-monospace">id</span>) and download merged output.</div>
        <div style="display:grid;gap:.45rem">
          <label class="status"><strong>Existing JSON</strong> <input id="fileA" type="file" accept="application/json"></label>
          <label class="status"><strong>New JSON</strong> <input id="fileB" type="file" accept="application/json"></label>
          <button class="btn" type="button" id="mergeBtn">Merge & download merged_recipes.json</button>
          <div id="mergeStatus" class="status"></div>
        </div>
      </div>

      <div>
        <div class="status" style="margin:.1rem 0 .35rem">Ingredient meta helper (optional). Adds a block you can paste into a recipe if you want explicit control.</div>
        <div style="display:flex;gap:.45rem;flex-wrap:wrap;align-items:center">
          <select id="metaId" style="flex:1;min-width:180px"></select>
          <input id="metaGrams" type="number" min="1" placeholder="grams" style="width:90px;border:1px solid var(--border);border-radius:10px;padding:.35rem .45rem;background:#fff">
          <button class="btn" type="button" id="metaAdd">Add</button>
          <button class="btn" type="button" id="metaCopy">Copy</button>
        </div>
        <pre id="metaOut"></pre>
      </div>
    </div>

    <div style="margin-top:.8rem">
      <div class="status" style="margin:.1rem 0 .35rem"><strong>Scan output</strong> (missing ingredient IDs + skeleton DB rows)</div>
      <pre id="scanOut"></pre>
    </div>
  </details>
</div>

<script>
/* =========================
   Core idea (Hybrid ‚ÄúC‚Äù):
   - Recipes stay lean: ingredients_html is the source of truth for humans.
   - Macros are computed automatically from:
       1) data-id + data-grams attributes (best, explicit),
       2) OR heuristics from plain text (good guesses),
       3) OR ingredients_meta if present (back-compat).
   - Ingredient DB lives here (per 10g). Expand this, not recipes.json.
   ========================= */

/** -------- Ingredient DB (per 10g) --------
 * Keep this curated. Add IDs as you discover gaps.
 * Fields are in grams (per 10g) except sodium/potassium in mg if you add them later.
 */
const NUTRITION_DB_10G = {
  // Beans / legumes (cooked/drained assumptions)
  "black-beans":   { kcal: 12, protein: 0.9, carbs: 2.0, fat: 0.1, satfat: 0.0, fiber: 0.8, sugars: 0.1, sodium: 2, potassium: 18 },
  "kidney-beans":  { kcal: 12, protein: 0.9, carbs: 2.1, fat: 0.1, satfat: 0.0, fiber: 0.8, sugars: 0.1, sodium: 2, potassium: 19 },
  "white-beans":   { kcal: 11, protein: 0.8, carbs: 2.0, fat: 0.1, satfat: 0.0, fiber: 0.7, sugars: 0.1, sodium: 2, potassium: 18 },
  "chickpeas":     { kcal: 12, protein: 0.6, carbs: 2.0, fat: 0.2, satfat: 0.0, fiber: 0.6, sugars: 0.1, sodium: 2, potassium: 18 },
  "lentils":       { kcal: 11, protein: 0.9, carbs: 2.0, fat: 0.1, satfat: 0.0, fiber: 0.8, sugars: 0.1, sodium: 1, potassium: 21 },

  // Oils / fats
  "olive-oil":     { kcal: 88, protein: 0.0, carbs: 0.0, fat: 10.0, satfat: 1.4, fiber: 0.0, sugars: 0.0, sodium: 0, potassium: 0 },
  "canola-oil":    { kcal: 88, protein: 0.0, carbs: 0.0, fat: 10.0, satfat: 0.7, fiber: 0.0, sugars: 0.0, sodium: 0, potassium: 0 },

  // Tomatoes / canned
  "tomato-canned": { kcal: 2,  protein: 0.1, carbs: 0.4, fat: 0.0, satfat: 0.0, fiber: 0.1, sugars: 0.3, sodium: 3, potassium: 25 },
  "tomato-paste":  { kcal: 8,  protein: 0.4, carbs: 1.8, fat: 0.1, satfat: 0.0, fiber: 0.4, sugars: 1.1, sodium: 10, potassium: 40 },

  // Staples
  "rice-cooked":   { kcal: 13, protein: 0.3, carbs: 2.9, fat: 0.0, satfat: 0.0, fiber: 0.1, sugars: 0.0, sodium: 0, potassium: 1 },
  "pasta-gf":      { kcal: 14, protein: 0.5, carbs: 2.9, fat: 0.1, satfat: 0.0, fiber: 0.2, sugars: 0.0, sodium: 0, potassium: 1 },

  // Sweeteners
  "maple-syrup":   { kcal: 26, protein: 0.0, carbs: 6.8, fat: 0.0, satfat: 0.0, fiber: 0.0, sugars: 6.6, sodium: 1, potassium: 4 },
  "honey":         { kcal: 30, protein: 0.0, carbs: 8.1, fat: 0.0, satfat: 0.0, fiber: 0.0, sugars: 8.1, sodium: 1, potassium: 5 },

  // Broth bases
  "veg-stock-paste": { kcal: 9, protein: 0.4, carbs: 1.2, fat: 0.3, satfat: 0.1, fiber: 0.1, sugars: 0.2, sodium: 700, potassium: 30 },
  "veg-stock-cube":  { kcal: 9, protein: 0.4, carbs: 1.2, fat: 0.3, satfat: 0.1, fiber: 0.1, sugars: 0.2, sodium: 900, potassium: 30 }
};

/** -------- Heuristic assumptions (your rules) -------- */
const ASSUME = {
  canBeansGrams: 540,   // 1 normal can of beans (wet) ~ 540 g
  canTomatoGrams: 400,  // 1 can tomatoes ~ 400 g
  tbspOilGrams: 15,     // drizzle = 1 tbsp
  tbspGenericGrams: 12, // maple/honey/etc.
  tspToTbsp: 1/3,
  cupCookedBeansGrams: 170,
  cupCookedRiceGrams: 180,
  sprinkleFlourGrams: 5
};

/** -------- Small utilities -------- */
function round1(x){ return Math.round(x*10)/10; }
function safeText(s){ return (s||"").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function parseNum(s){ const n = parseFloat(s); return Number.isFinite(n) ? n : null; }
function normalizeFractions(t){
  return (t||"")
    .replace(/¬Ω/g,"0.5").replace(/¬º/g,"0.25").replace(/¬æ/g,"0.75")
    .replace(/‚Öì/g,"0.33").replace(/‚Öî/g,"0.67");
}
function inferServings(meta){
  const m = /Serves\s+(\d+)/i.exec(meta||"");
  const n = m ? parseInt(m[1],10) : 4;
  return Number.isFinite(n) && n>0 ? n : 4;
}

/** -------- Ingredient name -> canonical id --------
 * This is the ‚Äúmillion-dollar‚Äù part: expand synonyms carefully.
 * Keep it deterministic (no AI hallucination in the browser).
 */
function mapTextToId(line){
  const t = line.toLowerCase();

  // beans / legumes
  if (t.includes("black bean")) return "black-beans";
  if (t.includes("kidney bean")) return "kidney-beans";
  if (t.includes("chickpea") || t.includes("garbanzo")) return "chickpeas";
  if (t.includes("lentil")) return "lentils";
  if (t.includes("pinto") || t.includes("navy") || t.includes("white bean")) return "white-beans";
  if (t.includes("bean") && t.includes("can")) return "black-beans"; // fallback bean can

  // tomatoes
  if (t.includes("tomato paste")) return "tomato-paste";
  if (t.includes("tomato") && (t.includes("can") || t.includes("cans"))) return "tomato-canned";
  if (t.includes("crushed tomato") || t.includes("diced tomato")) return "tomato-canned";

  // oils
  if (t.includes("olive oil")) return "olive-oil";
  if (t.includes("canola oil")) return "canola-oil";
  if ((t.includes("oil") || t.includes("drizzle")) && !t.includes("sesame")) return "olive-oil"; // default

  // grains
  if (t.includes("cooked rice") || (t.includes("rice") && t.includes("cup"))) return "rice-cooked";
  if (t.includes("gluten-free pasta") || t.includes("gf pasta") || t.includes("pasta")) return "pasta-gf";

  // sweeteners
  if (t.includes("maple syrup")) return "maple-syrup";
  if (t.includes("honey")) return "honey";

  // broth
  if (t.includes("veg stock paste") || t.includes("vegetable stock paste") || t.includes("bouillon paste")) return "veg-stock-paste";
  if (t.includes("veg stock cube") || t.includes("vegetable stock cube") || t.includes("bouillon cube")) return "veg-stock-cube";
  if (t.includes("vegetable broth") || t.includes("veg broth")) return "veg-stock-paste"; // assume paste powering broth

  return null;
}

/** -------- Parse quantity + unit from a line -------- */
function parseQtyUnit(line){
  const t = normalizeFractions(line.toLowerCase());

  // range "1‚Äì2" => take first for conservative consistency
  const range = t.match(/(\d+(\.\d+)?)\s*[-‚Äì]\s*(\d+(\.\d+)?)/);
  let qty = range ? parseFloat(range[1]) : null;

  if (!qty){
    const m = t.match(/(\d+(\.\d+)?)/);
    qty = m ? parseFloat(m[1]) : null;
  }

  let unit = null;
  if (t.includes("can") || t.includes("cans")) unit = "can";
  if (t.match(/\bml\b/)) unit = "ml";
  if (t.match(/\bg\b/)) unit = "g";
  if (t.includes("cup") || t.includes("cups")) unit = unit || "cup";
  if (t.includes("tbsp") || t.includes("tablespoon")) unit = unit || "tbsp";
  if (t.includes("tsp") || t.includes("teaspoon")) unit = unit || "tsp";
  if (t.includes("drizzle")) unit = unit || "drizzle";
  if (t.includes("sprinkle")) unit = unit || "sprinkle";

  if (!qty && (unit==="can" || unit==="drizzle" || unit==="sprinkle")) qty = 1;
  return { qty, unit };
}

/** -------- Estimate grams for a mapped id -------- */
function estimateGrams(id, line){
  const raw = normalizeFractions(line);
  const t = raw.toLowerCase();
  const { qty, unit } = parseQtyUnit(t);

  // explicit grams wins
  const gm = t.match(/(\d+(\.\d+)?)\s*g\b/);
  if (gm) return { grams: parseFloat(gm[1]), source: "exact" };

  // explicit ml ‚Üí treat as grams for waterlike items (tomatoes/beans/broth)
  const mm = t.match(/(\d+(\.\d+)?)\s*ml\b/);
  if (mm) return { grams: parseFloat(mm[1]), source: "exact" };

  // cans
  if (unit === "can"){
    const n = qty || 1;
    if (id.endsWith("beans") || id === "chickpeas" || id === "lentils") return { grams: n * ASSUME.canBeansGrams, source: "unit" };
    if (id === "tomato-canned") return { grams: n * ASSUME.canTomatoGrams, source: "unit" };
    // other canned items could go here
    return { grams: n * 300, source: "guess" };
  }

  // cups
  if (unit === "cup"){
    const n = qty || 1;
    if (id.endsWith("beans") || id === "chickpeas" || id === "lentils") return { grams: n * ASSUME.cupCookedBeansGrams, source: "unit" };
    if (id === "rice-cooked") return { grams: n * ASSUME.cupCookedRiceGrams, source: "unit" };
    if (id === "veg-stock-paste") {
      // broth in cups => convert to paste grams (5g paste per cup default)
      return { grams: n * 5, source: "guess" };
    }
    return { grams: n * 150, source: "guess" };
  }

  // tbsp/tsp/drizzle
  if (unit === "tbsp" || unit === "tsp" || unit === "drizzle"){
    const n = qty || 1;
    const tspFactor = (unit === "tsp") ? ASSUME.tspToTbsp : 1;
    if (id === "olive-oil" || id === "canola-oil"){
      return { grams: n * ASSUME.tbspOilGrams * tspFactor, source: "unit" };
    }
    if (id === "maple-syrup" || id === "honey"){
      return { grams: n * ASSUME.tbspGenericGrams * tspFactor, source: "unit" };
    }
    if (id === "tomato-paste"){
      // tomato paste tbsp ~ 16g
      return { grams: n * 16 * tspFactor, source: "unit" };
    }
    return { grams: n * ASSUME.tbspGenericGrams * tspFactor, source: "guess" };
  }

  // sprinkle
  if (unit === "sprinkle"){
    return { grams: ASSUME.sprinkleFlourGrams, source: "guess" };
  }

  // fallback if we have a qty but no unit
  if (qty){
    // assume qty is ‚Äúcount‚Äù (e.g., 2 tomatoes) ‚Üí ignore for now (or add produce tables later)
    return { grams: null, source: "guess" };
  }

  return { grams: null, source: "guess" };
}

/** -------- Extract meta from HTML --------
 * Priority:
 * 1) explicit data-id+data-grams (best)
 * 2) heuristic parse from LI text (good)
 */
function extractMetaFromIngredientsHtml(html){
  if (!html) return [];
  const tmp = document.createElement("div");
  tmp.innerHTML = html;

  const out = [];

  // 1) explicit attributes
  tmp.querySelectorAll("[data-id][data-grams]").forEach(el=>{
    const id = (el.getAttribute("data-id")||"").trim();
    const grams = parseNum(el.getAttribute("data-grams"));
    if (!id || !Number.isFinite(grams) || grams<=0) return;
    out.push({ id, grams, source:"exact", raw: el.textContent || "" });
  });

  // If we found explicit entries, trust them and stop.
  if (out.length) return out;

  // 2) heuristic parse from list items
  tmp.querySelectorAll("li").forEach(li=>{
    const raw = (li.textContent || "").trim();
    if (!raw) return;
    const id = mapTextToId(raw);
    if (!id) return;
    const { grams, source } = estimateGrams(id, raw);
    if (!grams || grams<=0) return;
    out.push({ id, grams, source, raw });
  });

  return out;
}

/** -------- Back-compat: allow ingredients_meta if present -------- */
function getIngredientsMeta(recipe){
  // Prefer HTML parsing for the ‚ÄúC‚Äù vision.
  const htmlMeta = extractMetaFromIngredientsHtml(recipe.ingredients_html || "");
  if (htmlMeta.length) return htmlMeta;

  // Fallback to ingredients_meta if older recipes rely on it
  if (Array.isArray(recipe.ingredients_meta) && recipe.ingredients_meta.length){
    return recipe.ingredients_meta.map(x=>({ id:x.id, grams:x.grams, source:"exact", raw:"(ingredients_meta)" }));
  }
  return [];
}

/** -------- Compute nutrition -------- */
function computeNutrition(recipe){
  const meta = getIngredientsMeta(recipe);
  if (!meta.length) return null;

  const totals = { kcal:0, protein:0, carbs:0, fat:0, satfat:0, fiber:0, sugars:0, sodium:0, potassium:0 };
  const used = [];

  for (const item of meta){
    const db = NUTRITION_DB_10G[item.id];
    if (!db) continue;
    const blocks = item.grams / 10;
    for (const k of Object.keys(totals)){
      const v = db[k];
      if (typeof v === "number") totals[k] += v * blocks;
    }
    used.push(item);
  }

  const servings = inferServings(recipe.meta);
  return {
    used,
    servings,
    per: {
      kcal: round1(totals.kcal/servings),
      protein: round1(totals.protein/servings),
      carbs: round1(totals.carbs/servings),
      fat: round1(totals.fat/servings),
      satfat: round1(totals.satfat/servings),
      fiber: round1(totals.fiber/servings),
      sugars: round1(totals.sugars/servings),
      sodium: Math.round(totals.sodium/servings),
      potassium: Math.round(totals.potassium/servings)
    }
  };
}

/** -------- UI rendering -------- */
const RECIPES_URL = "recipes.json";
let allRecipes = [];
let filtered = [];
let selectedId = null;

const listEl = document.getElementById("listEl");
const listMsg = document.getElementById("listMsg");
const detailEl = document.getElementById("detailEl");
const countEl = document.getElementById("countEl");
const searchInput = document.getElementById("searchInput");
const sectionFilter = document.getElementById("sectionFilter");

function iconFor(r){
  const t = (r.title||"").toLowerCase();
  const s = (r.section||"").toLowerCase();
  if (s.includes("soup") || t.includes("soup") || t.includes("stew")) return "ü•£";
  if (t.includes("bowl")) return "üç≤";
  if (t.includes("skillet")) return "üç≥";
  if (s.includes("dessert") || t.includes("cake") || t.includes("cookie")) return "üç∞";
  return "üçΩ";
}

function buildSectionFilter(recipes){
  const secs = Array.from(new Set(recipes.map(r=>r.section||"").filter(Boolean)))
    .sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
  sectionFilter.innerHTML = '<option value="">All sections</option>';
  secs.forEach(sec=>{
    const o = document.createElement("option");
    o.value = sec; o.textContent = sec;
    sectionFilter.appendChild(o);
  });
}

function applyFilters(){
  const term = (searchInput.value||"").trim().toLowerCase();
  const sec = sectionFilter.value;

  filtered = allRecipes.filter(r=>{
    if (sec && (r.section||"") !== sec) return false;
    if (!term) return true;
    const hay = ((r.title||"") + " " + (r.meta||"") + " " + (r.ingredients_html||"") + " " + (r.usage_html||"")).toLowerCase();
    return hay.includes(term);
  });

  if (selectedId && !filtered.some(r=>r.id===selectedId)){
    selectedId = null;
    renderDetail(null);
  }

  renderList();
  countEl.textContent = `${filtered.length} of ${allRecipes.length}`;
}

function renderList(){
  listEl.innerHTML = "";
  listMsg.style.display = "none";

  if (!filtered.length){
    listMsg.style.display = "block";
    listMsg.className = "status bad";
    listMsg.textContent = "No recipes match your search/filters.";
    return;
  }

  const bySec = {};
  filtered.forEach(r=>{
    const sec = r.section || "Uncategorized";
    (bySec[sec] ||= []).push(r);
  });

  Object.keys(bySec).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"})).forEach(sec=>{
    const lab = document.createElement("div");
    lab.className = "sectionLabel";
    lab.textContent = sec;
    listEl.appendChild(lab);

    bySec[sec].forEach(r=>{
      const d = document.createElement("div");
      d.className = "cardItem" + (r.id===selectedId ? " selected" : "");
      d.addEventListener("click", ()=>{ selectedId = r.id; renderList(); renderDetail(r); });

      const title = document.createElement("div");
      title.className = "cardTitle";
      title.textContent = `${iconFor(r)} ${r.title || "Untitled recipe"}`;

      const meta = document.createElement("div");
      meta.className = "cardMeta";
      meta.textContent = r.meta || "";

      d.appendChild(title);
      d.appendChild(meta);
      listEl.appendChild(d);
    });
  });
}

function nutritionHtml(n){
  if (!n) return `<p>No nutrition info yet.</p><p class="note">Tip: add <code>data-id</code> + <code>data-grams</code> to big ingredients for best accuracy, or rely on smart defaults.</p>`;

  const srcCounts = n.used.reduce((acc,x)=>{ acc[x.source]=(acc[x.source]||0)+1; return acc; }, {});
  const srcLine = Object.keys(srcCounts).map(k=>`${k}:${srcCounts[k]}`).join(" ¬∑ ");

  return `
    <h3>Nutrition</h3>
    <div class="note">Auto-estimated per serving (Serves ${n.servings}). Sources: ${srcLine || "‚Äî"}</div>
    <ul>
      <li><strong>Calories</strong>: ${n.per.kcal} kcal</li>
      <li><strong>Protein</strong>: ${n.per.protein} g</li>
      <li><strong>Carbs</strong>: ${n.per.carbs} g</li>
      <li><strong>Fat</strong>: ${n.per.fat} g</li>
      <li><strong>Fiber</strong>: ${n.per.fiber} g</li>
      <li><strong>Sugars</strong>: ${n.per.sugars} g</li>
      <li><strong>Sodium</strong>: ${n.per.sodium} mg</li>
      <li><strong>Potassium</strong>: ${n.per.potassium} mg</li>
    </ul>
    <div class="note">These are estimates. The goal is consistency + usefulness, not lab precision.</div>
  `;
}

function renderDetail(r){
  if (!r){
    detailEl.innerHTML = `<div class="status">Select a recipe to view ingredients, method, and auto macros.</div>`;
    return;
  }

  const n = computeNutrition(r);

  const badges = [
    r.section ? `<span class="badge">${safeText(r.section)}</span>` : "",
    `<span class="badge">Vegetarian ¬∑ Gluten-Free</span>`,
    n ? `<span class="badge">Auto Macros</span>` : `<span class="badge">No Macros</span>`
  ].filter(Boolean).join("");

  detailEl.innerHTML = `
    <div class="detailHeader">
      <h2>${safeText(r.title || "Untitled recipe")}</h2>
      <div class="detailMeta">${safeText((r.section ? r.section + " ¬∑ " : "") + (r.meta || ""))}</div>
      <div class="badgeRow">${badges}</div>
    </div>

    <div class="cols">
      <div style="display:grid;gap:.75rem">
        <div class="block">
          <h3>Ingredients</h3>
          ${r.ingredients_html || "<p>No ingredients listed.</p>"}
        </div>
        <div class="block">
          <h3>Usage and storage</h3>
          ${r.usage_html || "<p>‚Äî</p>"}
        </div>
      </div>

      <div style="display:grid;gap:.75rem">
        <div class="block">
          <h3>Method</h3>
          ${r.method_html || "<p>No method provided.</p>"}
        </div>
        <div class="block">
          ${nutritionHtml(n)}
        </div>
      </div>
    </div>
  `;
}

/** -------- Download current loaded cookbook -------- */
document.getElementById("downloadBtn").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(allRecipes, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "recipes.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

/** -------- Ingredient coverage scan -------- */
function scanCoverage(){
  if (!allRecipes.length){
    document.getElementById("scanOut").textContent = "No recipes loaded yet.";
    return;
  }
  const used = new Set();
  const idToTitles = new Map();

  allRecipes.forEach(r=>{
    // gather from explicit HTML data-id, heuristic mapping, and ingredients_meta
    const meta = getIngredientsMeta(r);
    meta.forEach(m=>{
      used.add(m.id);
      (idToTitles.get(m.id) || idToTitles.set(m.id, []).get(m.id)).push(r.title || r.id || "Untitled");
    });
  });

  const dbIds = new Set(Object.keys(NUTRITION_DB_10G));
  const missing = Array.from(used).filter(id=>!dbIds.has(id)).sort();
  const lines = [];
  lines.push(`Recipes: ${allRecipes.length}`);
  lines.push(`Unique IDs used in macro engine: ${used.size}`);
  lines.push(`Missing in NUTRITION_DB_10G: ${missing.length}`);
  lines.push("");

  if (missing.length){
    lines.push("Missing IDs and sample recipes:");
    missing.forEach(id=>{
      const sample = (idToTitles.get(id) || []).slice(0,3).join(" | ");
      lines.push(`- ${id}  ‚Üê ${sample}`);
    });
    lines.push("");
    lines.push("Skeleton DB entries to paste:");
    missing.forEach(id=>{
      lines.push(`"${id}": { kcal: 0, protein: 0, carbs: 0, fat: 0, satfat: 0, fiber: 0, sugars: 0, sodium: 0, potassium: 0 },`);
    });
  } else {
    lines.push("All macro IDs are covered. ‚úÖ");
  }

  document.getElementById("scanOut").textContent = lines.join("\n");
}

/** -------- Wire scan button -------- */
document.getElementById("scanBtn").addEventListener("click", scanCoverage);

/** -------- Search/filter handlers -------- */
searchInput.addEventListener("input", applyFilters);
sectionFilter.addEventListener("change", applyFilters);

/** -------- Merge tool -------- */
function readFileJson(file){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onload = ()=>{ try{ resolve(JSON.parse(fr.result)); } catch(e){ reject(e); } };
    fr.onerror = ()=>reject(new Error("file read error"));
    fr.readAsText(file);
  });
}
document.getElementById("mergeBtn").addEventListener("click", async ()=>{
  const a = document.getElementById("fileA").files?.[0];
  const b = document.getElementById("fileB").files?.[0];
  const st = document.getElementById("mergeStatus");
  if (!a || !b){ st.textContent = "Select both files."; st.className="status bad"; return; }
  st.textContent = "Merging‚Ä¶"; st.className="status";
  try{
    const A = await readFileJson(a);
    const B = await readFileJson(b);
    if (!Array.isArray(A) || !Array.isArray(B)) throw new Error("Both files must be arrays.");
    const map = new Map();
    let replaced=0, added=0, skipped=0;
    A.forEach(r=>{ if (r && r.id) map.set(r.id, r); else skipped++; });
    B.forEach(r=>{
      if (!r || !r.id){ skipped++; return; }
      if (map.has(r.id)) replaced++; else added++;
      map.set(r.id, r);
    });
    const merged = Array.from(map.values());
    const blob = new Blob([JSON.stringify(merged, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "merged_recipes.json";
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
    st.textContent = `Merged: ${merged.length} total ¬∑ ${replaced} replaced ¬∑ ${added} added ¬∑ ${skipped} skipped`;
    st.className = "status ok";
  } catch(e){
    st.textContent = "Merge failed: " + (e?.message || e);
    st.className = "status bad";
  }
});

/** -------- Meta helper -------- */
const metaIds = Object.keys(NUTRITION_DB_10G).sort();
const metaSelect = document.getElementById("metaId");
metaSelect.innerHTML = metaIds.map(id=>`<option value="${id}">${id}</option>`).join("");
let metaList = [];
function renderMeta(){
  const pre = document.getElementById("metaOut");
  pre.textContent = `"nutrition_mode": "auto",\n"ingredients_meta": [\n` +
    metaList.map(m=>`  { "id": "${m.id}", "grams": ${m.grams} }`).join(",\n") +
    `\n]`;
}
document.getElementById("metaAdd").addEventListener("click", ()=>{
  const id = metaSelect.value;
  const g = parseInt(document.getElementById("metaGrams").value, 10);
  if (!g || g<1) return;
  metaList.push({id, grams:g});
  renderMeta();
});
document.getElementById("metaCopy").addEventListener("click", async ()=>{
  const txt = document.getElementById("metaOut").textContent.trim();
  if (!txt) return;
  try{ await navigator.clipboard.writeText(txt); } catch(e){}
});

/** -------- Load recipes -------- */
async function load(){
  try{
    const res = await fetch(RECIPES_URL, {cache:"no-store"});
    if (!res.ok) throw new Error("Could not load recipes.json");
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("recipes.json must be an array");
    allRecipes = data;
    buildSectionFilter(allRecipes);
    filtered = [...allRecipes];
    applyFilters();
    // auto-select first recipe for convenience
    if (filtered.length){
      selectedId = filtered[0].id;
      renderDetail(filtered[0]);
      renderList();
    }
  } catch(e){
    listMsg.style.display = "block";
    listMsg.className = "status bad";
    listMsg.textContent = "Load error: " + (e?.message || e);
  }
}
load();
</script>
</body>
</html>
